# learn_design_pattern

看设计模式时，随手敲下书中例子，同时也会做些改动，另外，也会写些书中没有的。

# 设计原则

* 封装变化

* 多用组合，少用继承

* 针对接口编程，不针对实现编程

* 为交互对象之间的松耦合设计而努力

# 模式

1. 策略模式（Strategy Pattern）：定义算法簇，让他们之间可以互相替换，从而让算法的变化独立于使用算法的客户。


2. 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新。

    * Observer 实现一个共同的接口。

    * 观察者模式可以有两种方式，一是push，二是pull。

    * java.util包内置了观察者模式，可以支持pull和push两种方式，但是，有几个缺点：1. Subject 通知 observer 的顺序与注册顺序不同，如果代码依赖于这种顺序，那么，就会出错；2. java.util.Obervable 即Subject是一个抽象类，没有实现一个接口，限制了Obervable的复用能力；3. Observable的setChanged方法是protected的，不好组合。

    * 尽量自定义观察者模式吧。


3. 单件模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。

4. 代理模式 （Proxy）：为另一个对象提供一个替身或占位符以控制对这个对象的访问。

    * 多种模式

        * 远程代理控制访问远程对象

        * 虚拟代理控制访问创建开销大的资源

        * 保护代理基于权限控制对资源的访问

       * ...

    *  重点是对被代理对象进行控制访问。

    * Java 内置代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
    
5. 装饰者模（Decorator）动态的将责任附加到对象上。

    ﻿* 提供比继承更有弹性的方案来实现扩展功能。

    ﻿* 装饰者与被装饰者具有相同的超类

    ﻿* 装饰者有个实例变量保存被装饰者的引用

    ﻿* 装饰者一般对组件是透明的。

    ﻿* 装饰者会导致过多小对象，若过度使用，会让程序变复杂。

